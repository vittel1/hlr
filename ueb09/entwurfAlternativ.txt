calculate:

int i,j;
double star,
double residuum, maxresiduum;

int const N = arguments->N;
double const h = arguments->h;

double pih = 0.0;
double fpisin = 0.0;

int term_iteration = options->term_iteration;

if(options->inf_func == FUNC_PISIN)
	pih = PI *h;
	fpisin = 0.25 * TWO_PI_SQUARE * h * h;


if(rank != 0)
	MPI_Send(myFirstLine, toPredecessor);


while(term_iteration > 0)

	double** matrix = arguments->Matrix[0];


	for(i = 1; i < lines; i++)
		
		//Die erste Zeile wird in der ersten Iteration empfangen, da sie hier benötigt wird
		if(i == 1 && rank != 0 )
			MPI_Recv(newFirstLine, fromPredecessor);
			matrix[0] = newFirstLine;
		
		//Die letzte Zeile wird erst in der letzten Iteration empfangen, weil sie vorher nicht benötigt wird
		if(i == lines - 1 && rank != lastRank)
			MPI_Recv(newLastLine, fromSuccessor)
			matrix[lastIndex] = newLastLine;

		double fpisin_i = 0.0;
		if(options->inf_func == FUNC_PISIN)
			double adaptedI = rank == 0 ? (double) i : (double)(i - 1 + globalStart);
			fpisin_i = fpisin * sin(pih * adaptedI);

		for(j = 1; j < N; j++)
			star = 0.25 * matrixEntries
			
			if(options->inf_func == FUNC_PISIN)
				star += fpisin_i * sin(pih * (double) j);

			if(options->termination == TERM_PREC || term_iteration == 1)
				residuum = matrixAfterCommunication[i][j] - star;
				residuum = abs(residuum);
				maxresiduum = max(maxresiduum, residuum);

			matrix[i][j] = star;

		//Wenn die erste Zeile fertig ist, schicke sie an Vorgänger
		if(i == 1 && rank != 0)
			MPI_Send(matrixLineAtIndexI, toPredecessor);
		//Wenn die letzte Zeile fertig berechnet ist, verschicke sie an Nachfolger
		if(i == lines - 1 && rank != lastRank)
			MPI_Send(matrixLineAtIndexI, toSuccessor);


	results->stat_iteration++;
	results->stat_precision = maxresiduum;
	
	

	//wenn nach Genauigkeit abgebrochen werden soll, sendet jeder Prozess nacheinander sein maxresiduum
	//an den Verwaltungsprozess und falls das lokale maxresiduum unter der geforderten Präzision ist,
	//wartet der betroffene Prozess, bis der Verwaltungsprozess übermittelt, ob tatsächlich abgebrochen
	//werden soll oder nicht
	if(options->termination == TERM_PREC)
		MPI_Send(maxresiduum, toManagement);
		
		if(maxresiduum < options->term_precision)
			int abort;
			MPI_Recv(askManagementProcess and save answer in abort);
			if(abort)
				term_iteration = 0;
				MPI_Recv(maxresiduum, reducedMaxresiduumFromManagement);

	//Wenn nach Iteration abgebrochen werden soll, wird immer nur die Iterationszahl dekrementiert.
	//In der letzten Iteration wird maxresiduum dann reduziert.
	else if(options->termination == TERM_ITER)
		if(term_iteration == 1)
			MPI_Allreduce(maxresiduum, MPI_MAX);
		term_iteration--;

results->m = 0;



//Falls Genauigkeit das Abbruchkriterium ist, gilt folgendes:
//der höchstrangige Prozess wird nicht mitrechnen, stattdessen verwaltet er die maxresiduums der anderen

managePrecision:

double term_precision = options->term_precision;
double maxresiduum;
int abort = 0;

while(true)
	
	double maxresiduumOneIteration = 0.0;
	Array processesToInformAboutAborting[world_size - 2] = 0 for every entry;
	
	for(int i = 0; i < world_size - 2; i++)
		double newresiduum;		
		MPI_Recv(newresiduum, fromProcessWithRankI);
		
		if(newresiduum < term_precision)
			processesToInformAboutAborting[i] = 1;

		maxresiduumOneIteration = max(newresiduum, maxresiduumAll)

	maxresiduum = maxresiduumOneIteration;
	if(maxresiduum < term_precision)
		abort = 1;
	
	for(every 1 in processesToInformAboutAborting)
		MPI_Send(abort, toCorrespondingProcess);

	if(abort == 1)
		return;
